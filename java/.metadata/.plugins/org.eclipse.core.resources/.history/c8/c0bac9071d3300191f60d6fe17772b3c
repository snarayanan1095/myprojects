package algo_hw5;




import java.io.*;             
import java.lang.Integer;      

class DataItem
{
public double dData;       

public DataItem(double dd)  
   { dData = dd; }

public void displayItem()   
   { System.out.print("/"+dData); }

}  
class Node
{
private static final int ORDER = 4;
private int numItems;
private Node parent;
private Node childArray[] = new Node[ORDER];
private DataItem itemArray[] = new DataItem[ORDER-1];

public void connectChild(int childNum, Node child)
   {
   childArray[childNum] = child;
   if(child != null)
      child.parent = this;
   }

public Node disconnectChild(int childNum)
   {
   Node tempNode = childArray[childNum];
   childArray[childNum] = null;
   return tempNode;
   }

public Node getChild(int childNum)
   { return childArray[childNum]; }

public Node getParent()
   { return parent; }
public boolean isLeaf()
   { return (childArray[0]==null) ? true : false; }

public int getNumItems()
  { return numItems; }

public DataItem getItem(int index)  
   { return itemArray[index]; }

public boolean isFull()
   { return (numItems==ORDER-1) ? true : false; }

public int findItem(double key)        

   {                                    
   for(int j=0; j<ORDER-1; j++)       
      {                                 
      if(itemArray[j] == null)          
         break;
      else if(itemArray[j].dData == key)
         return j;
      }
   return -1;
   } 
public int insertItem(DataItem newItem)
   {
   
   numItems++;                        
   double newKey = newItem.dData;       



   for(int j=ORDER-2; j>=0; j--)        
      {                               
      if(itemArray[j] == null)          
         continue;                      
      else                             
         {                             
         double itsKey = itemArray[j].dData;
         if(newKey < itsKey)           
            itemArray[j+1] = itemArray[j]; 
         else
            {
            itemArray[j+1] = newItem;  
            return j+1;                 
            }                         
         } 
      }  
   itemArray[0] = newItem;             
   return 0;
   }  

public DataItem removeItem()        
   {
  
   DataItem temp = itemArray[numItems-1]; 
   itemArray[numItems-1] = null;          
   numItems--;                           
   return temp;                          
   }

public void displayNode()          
   {
   for(int j=0; j<numItems; j++)
      itemArray[j].displayItem();   
   System.out.println("/");         
   }
}  

class Tree234
{
private Node root = new Node();            
public int find(double key)
   {
   Node curNode = root;
   int childNumber;
   while(true)
      {
      if(( childNumber=curNode.findItem(key) ) != -1)
         return childNumber;              
      else if( curNode.isLeaf() )
         return -1;                       
      else                                
         curNode = getNextChild(curNode, key);
      }  
   }

public void insert(double dValue)



   {
   Node curNode = root;
   DataItem tempItem = new DataItem(dValue);

   while(true)
      {
      if( curNode.isFull() )              
         {
         split(curNode);                  
         curNode = curNode.getParent();   
                                           
         curNode = getNextChild(curNode, dValue);
         }  
      else if( curNode.isLeaf() )         
         break;                            
      else
         curNode = getNextChild(curNode, dValue);
      }  

   curNode.insertItem(tempItem);      
   }  
public void split(Node thisNode)    
   {
 
   DataItem itemB, itemC;
   Node parent, child2, child3;
   int itemIndex;

   itemC = thisNode.removeItem();    
   itemB = thisNode.removeItem();    
   child2 = thisNode.disconnectChild(2); 
   child3 = thisNode.disconnectChild(3); 

   Node newRight = new Node();      

   if(thisNode==root)            
      {
      root = new Node();              
      parent = root;                   
      root.connectChild(0, thisNode);   // connect to parent
      }
   else                              // this node not the root
      parent = thisNode.getParent();    // get parent

   // deal with parent
   itemIndex = parent.insertItem(itemB); // item B to parent
   int n = parent.getNumItems();         // total items?

   for(int j=n-1; j>itemIndex; j--)          // move parent's
      {                                      // connections
      Node temp = parent.disconnectChild(j); // one child
      parent.connectChild(j+1, temp);        // to the right
      }
                                // connect newRight to parent
   parent.connectChild(itemIndex+1, newRight);

   // deal with newRight
   newRight.insertItem(itemC);       // item C to newRight
   newRight.connectChild(0, child2); // connect to 0 and 1
   newRight.connectChild(1, child3); // on newRight
   }  // end split()
//-------------------------------------------------------------
// gets appropriate child of node during search for value
public Node getNextChild(Node theNode, double theValue)
   {

//Should be able to do this w/o a loop, since we should know
//index of correct child already

   int j;
   // assumes node is not empty, not full, not a leaf
   int numItems = theNode.getNumItems();
   for(j=0; j<numItems; j++)          // for each item in node
      {                               // are we less?
      if( theValue < theNode.getItem(j).dData )
         return theNode.getChild(j);  // return left child
      }  // end for                   // we're greater, so
   return theNode.getChild(j);        // return right child
   }
//-------------------------------------------------------------
public void displayTree()
   {
   recDisplayTree(root, 0, 0);
   }
//-------------------------------------------------------------
private void recDisplayTree(Node thisNode, int level,
                                           int childNumber)
   {
   System.out.print("level="+level+" child="+childNumber+" ");
   thisNode.displayNode();               // display this node

   // call ourselves for each child of this node
   int numItems = thisNode.getNumItems();
   for(int j=0; j<numItems+1; j++)
      {
      Node nextNode = thisNode.getChild(j);
      if(nextNode != null)
         recDisplayTree(nextNode, level+1, j);
      else
         return;
      }
   }  // end recDisplayTree()
//-------------------------------------------------------------\
}  // end class Tree234
////////////////////////////////////////////////////////////////
class Tree234App
{
public static void main(String[] args) throws IOException
   {
   double value;
   Tree234 theTree = new Tree234();

   theTree.insert(50);
   theTree.insert(40);
   theTree.insert(60);
   theTree.insert(30);
   theTree.insert(70);

   while(true)
      {
      putText("Enter first letter of ");
      putText("show, insert, or find: ");
      char choice = getChar();
      switch(choice)
         {
         case 's':
            theTree.displayTree();
            break;
         case 'i':
            putText("Enter value to insert: ");
            value = getInt();
            theTree.insert(value);
            break;
         case 'f':
            putText("Enter value to find: ");
            value = getInt();
            int found = theTree.find(value);
            if(found != -1)
               System.out.println("Found "+value);
            else
               System.out.println("Could not find "+value);
            break;
         default:
            putText("Invalid entry\n");
         } 
      } 
   }  

public static void putText(String s)
   {
   System.out.print(s);
   System.out.flush();
   }

public static String getString() throws IOException
   {
   InputStreamReader isr = new InputStreamReader(System.in);
   BufferedReader br = new BufferedReader(isr);
   String s = br.readLine();
   return s;
   }

public static char getChar() throws IOException
   {
   String s = getString();
   return s.charAt(0);
   }


public static int getInt() throws IOException
   {
   String s = getString();
   return Integer.parseInt(s);
   }

}  // end class Tree234App

